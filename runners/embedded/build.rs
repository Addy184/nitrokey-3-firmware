use core::ops::Range;
use std::str;
use std::{env, error, fs::File, io::Write, path::Path};

struct MemoryRegions {
    firmware: Range<usize>,
    filesystem: Range<usize>,
}

#[cfg(feature = "soc-lpc55")]
const MEMORY_REGIONS: MemoryRegions = MemoryRegions {
    firmware: 0..0x92_000,
    filesystem: 0x93_000..0x9D_E00,
};
#[cfg(feature = "soc-nrf52840")]
const MEMORY_REGIONS: MemoryRegions = MemoryRegions {
    firmware: 0x1_000..0xD8_000,
    filesystem: 0xD8_000..0xEC_000,
};

#[derive(Eq, PartialEq)]
enum SocType {
    Lpc55,
    Nrf52840,
}

macro_rules! add_build_variable {
    ($file:expr, $name:literal, u8) => {
        let value = env!($name);
        let value: u8 = str::parse(value).expect("Version components must be able to fit in a u8.");
        writeln!($file, "pub const {}: u8 = {};", $name, value)
            .expect("Could not write build_constants.rs file");
    };

    ($file:expr, $name:literal, $value:expr, u16) => {
        writeln!($file, "pub const {}: u16 = {};", $name, $value)
            .expect("Could not write build_constants.rs file");
    };

    ($file:expr, $name:literal, $value:expr, u32) => {
        writeln!($file, "pub const {}: u32 = {};", $name, $value)
            .expect("Could not write build_constants.rs file");
    };

    ($file:expr, $name:literal, $value:expr, usize) => {
        writeln!($file, "pub const {}: usize = 0x{:x};", $name, $value)
            .expect("Could not write build_constants.rs file");
    };

    ($file:expr, $name:literal, $value:expr, [u8; 13]) => {
        writeln!($file, "pub const {}: [u8; 13] = {:?};", $name, $value)
            .expect("Could not write build_constants.rs file");
    };

    ($file:expr, $name:literal, $value:expr) => {
        writeln!($file, "pub const {}: &str = \"{}\";", $name, $value)
            .expect("Could not write build_constants.rs file");
    };
}

fn check_build_triplet() -> SocType {
    let target = env::var("TARGET").expect("$TARGET unset");
    let soc_is_lpc55 = env::var_os("CARGO_FEATURE_SOC_LPC55").is_some();
    let soc_is_nrf52840 = env::var_os("CARGO_FEATURE_SOC_NRF52840").is_some();

    if soc_is_lpc55 && !soc_is_nrf52840 {
        if target != "thumbv8m.main-none-eabi" {
            panic!(
                "Wrong build triplet for LPC55, expecting thumbv8m.main-none-eabi, got {}",
                target
            );
        }
        SocType::Lpc55
    } else if soc_is_nrf52840 && !soc_is_lpc55 {
        if target != "thumbv7em-none-eabihf" {
            panic!(
                "Wrong build triplet for NRF52840, expecting thumbv7em-none-eabihf, got {}",
                target
            );
        }
        SocType::Nrf52840
    } else {
        panic!("Multiple or no SOC features set.");
    }
}

fn generate_memory_x(outpath: &Path, template: &str, regions: &MemoryRegions) {
    let buildrs_caveat = r#"/* DO NOT EDIT THIS FILE */
/* This file was generated by build.rs */
"#;

    let template = std::fs::read_to_string(template).expect("cannot read memory.x template file");

    let fw_len = regions.firmware.len();
    let template = template.replace("##FLASH_LENGTH##", &format!("{fw_len:#X}"));

    let fs_len = regions.filesystem.len();
    let template = template.replace("##FS_LENGTH##", &format!("{fs_len:#X}"));

    let template = template.replace("##FS_BASE##", &format!("{:#X}", regions.filesystem.start));
    let template = template.replace("##FLASH_BASE##", &format!("{:#X}", regions.firmware.start));

    std::fs::write(outpath, [buildrs_caveat, &template].join("")).expect("cannot write memory.x");
}

fn main() -> Result<(), Box<dyn error::Error>> {
    let out_dir = env::var("OUT_DIR").expect("$OUT_DIR unset");

    // @todo: add profile 'platform' items and cross-check them here ...
    let soc_type = check_build_triplet();

    if MEMORY_REGIONS.filesystem.start & 0x3ff != 0 {
        panic!("filesystem boundary is not a multiple of the flash block size (1KB)");
    }

    // open and prepare 'build_constants.rs' output
    let dest_path = Path::new(&out_dir).join("build_constants.rs");
    let mut f = File::create(&dest_path).expect("Could not create file");

    // write 'build_constants.rs' header
    writeln!(&mut f, "pub mod build_constants {{").expect("Could not write build_constants.rs.");

    add_build_variable!(
        &mut f,
        "CONFIG_FILESYSTEM_BOUNDARY",
        MEMORY_REGIONS.filesystem.start,
        usize
    );
    add_build_variable!(
        &mut f,
        "CONFIG_FILESYSTEM_END",
        MEMORY_REGIONS.filesystem.end,
        usize
    );
    add_build_variable!(
        &mut f,
        "CONFIG_FLASH_BASE",
        MEMORY_REGIONS.firmware.start,
        usize
    );
    add_build_variable!(
        &mut f,
        "CONFIG_FLASH_END",
        MEMORY_REGIONS.firmware.end,
        usize
    );

    writeln!(&mut f, "}}").expect("Could not write build_constants.rs.");

    // @todo: move this decision into 'profile.cfg'
    let (memory_x_infix, template_file) = match soc_type {
        SocType::Lpc55 => ("ld/lpc55", "ld/lpc55-memory-template.x"),
        SocType::Nrf52840 => ("ld/nrf52", "ld/nrf52-memory-template.x"),
    };

    println!("cargo:rerun-if-changed={}", template_file);
    println!("cargo:rerun-if-changed={}", template_file);

    let memory_x_dir =
        Path::new(&env::var("CARGO_MANIFEST_DIR").expect("$CARGO_MANIFEST_DIR not set"))
            .join(&memory_x_infix);
    std::fs::create_dir(&memory_x_dir).ok();
    let memory_x = memory_x_dir.join("custom_memory.x");

    generate_memory_x(&memory_x, template_file, &MEMORY_REGIONS);

    println!("cargo:rustc-link-search={}/ld", env!("CARGO_MANIFEST_DIR"));
    println!(
        "cargo:rustc-link-search={}/{}",
        env!("CARGO_MANIFEST_DIR"),
        memory_x_infix
    );

    let lockfile =
        cargo_lock::Lockfile::load(Path::new(env!("CARGO_MANIFEST_DIR")).join("../../Cargo.lock"))?;
    let pkg_cortex_m_rt = lockfile
        .packages
        .iter()
        .find(|p| p.name.as_str() == "cortex-m-rt");

    if let Some(p) = pkg_cortex_m_rt {
        println!("cargo:rustc-link-arg=-Tcortex-m-rt_{}_link.x", p.version);
    }

    Ok(())
}
